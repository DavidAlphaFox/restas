<html> <head> <meta http-equiv="Content-Type" content="text/html; charset='utf-8'" /> <meta name="keywords" content="restas,web,framework,web framework,REST,Common Lisp,lisp" /> <title>Модули</title> <link rel="stylesheet" type="text/css" href="../static/style.css" /> </head> <body> <a href="http://github.com/archimag/restas/"> <img style="position: absolute; top: 0; right: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_right_white_ffffff.png" alt="Fork me on GitHub"> </a> <div id="frame"> <div id="page-title"> <h1>RESTAS</h1> <b>Фрэймворк для разработки web-приложений на Common Lisp</b> </div> <div id="menu"> <ul> <li> <a href="../index.html">Начало</a>  </li><li> <a href="../overview.html">Обзор</a>  </li><li> <a href="../installation.html">Установка</a>  </li><li> <a href="../tutorial/contents.html">Введение</a> <ul> <li> <a href="../tutorial/hello-world.html">Hello World</a> </li><li> <a href="../tutorial/pastebin.html">Pastebin</a> </li> </ul> </li><li> <a href="contents.html">Руководство</a> <ul> <li> <a href="routes.html">Маршруты</a> </li><li> <strong>Модули</strong> </li><li> <a href="view.html">Представление</a> </li><li> <a href="special-pages.html">Специальные страницы</a> </li><li> <a href="decorators.html">Декораторы</a> </li><li> <a href="daemon.html">Демонизация</a> </li><li> <a href="slime.html">SLIME</a> </li> </ul> </li><li> <a href="../ref/index.html">API Reference</a>  </li> </ul> </div> <div id="content"> <div id="модули" class="document"><h1>Модули<a href="#модули" class="headerlink" title="Permalink to this headline">¶</a></h1><h2 id="module">Module<a href="#module" class="headerlink" title="Permalink to this headline">¶</a></h2><a id="manual-modules" class="target" name="manual-modules"></a><p>С точки зрения Common Lisp, модуль -- это просто пакет(<a href="http://www.lispworks.com/reference/HyperSpec/Body/t_pkg.htm" class="common-lisp-entity">package</a>). С точки зрения <a class="reference" href="http://restas.lisper.ru/"><span>RESTAS</span></a> модуль -- это набор маршрутов , определяющих структуру web-приложения. Модуль создаётся с помощью макроса <a class="common-lisp-entity" href="../ref/index.html#restas-define-module">restas:define-module</a>, который создаёт пакет с соответствующим именем, а ещё проводит некоторую дополнительную инициализацию этого пакета. Например:</p>
<p><div class="code"><span class="paren1">(<span class=""><i><span class="symbol">restas:define-module</span></i> <span class="keyword">#:hello-world</span><br>&nbsp;&nbsp;<span class="paren2">(<span class=""><span class="keyword">:use</span> <span class="keyword">#:cl</span></span>)</span></span>)</span></div></p>
<p>Теперь можно создать в этом модуле несколько маршрутов:</p>
<p><div class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_in_pkg.htm" class="symbol">in-package</a> <span class="keyword">#:hello-world</span></span>)</span><br><br>
<span class="paren1">(<span class=""><i><span class="symbol">restas:define-route</span></i> main <span class="paren2">(<span class=""><span class="string">"hello"</span></span>)</span><br>&nbsp;&nbsp;<span class="string">"&lt;h1&gt;Hello world!&lt;/h1&gt;"</span></span>)</span></div></p>
<p>Обращаю внимание на принципиальную важность раскрытия макроса <a class="common-lisp-entity" href="../ref/index.html#restas-define-route">restas:define-route</a> в пакете (после <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_in_pkg.htm" class="common-lisp-entity">in-package</a>), связанном с определённым модулем.</p>
<p>И наконец, полученный модуль можно запустить как web-сайт:</p>
<p><div class="code"><span class="paren1">(<span class="">restas:start '<span class="keyword">#:hello-world</span> <span class="keyword">:port</span> 8080</span>)</span></div></p>
<p>В функцию <a class="common-lisp-entity" href="../ref/index.html#restas-start">restas:start</a> можно также передать ключевой параметр :hostname, что позволяет обслуживать несколько виртуальных хостов в рамках одного процесса.</p>
<p>Таким образом, после размешения в модуле нескольких маршрутов, модуль можно использовать для запуска web-приложения. Но у модулей есть ещё и другой вариант использования.</p>
<div id="подмодули" class="section"><h2>Подмодули<a href="#подмодули" class="headerlink" title="Permalink to this headline">¶</a></h2><p>Модули предлагают интересный подход к повторному использованию кода при разработке web-приложений. Отличие web-компонента  от простой библиотеки, содержащей функции, макросы, классы и т.п в том, что web-компонент также должен содержать информацию об обслуживаемых им url, и эту информацию надо использовать в механизме диспетчеризации запросов, правильно определяя код, ответственный за обработку поступившего запроса. В терминах routes (маршрутов) любой повторно используемый web-компонент является просто списком обрабатываемых им маршрутов, а это как раз и есть то, чем являются модули с точки зрения <a class="reference" href="http://restas.lisper.ru/"><span>RESTAS</span></a>. Для повторного использования модуля из другого модуля используется макрос <a class="common-lisp-entity" href="../ref/index.html#restas-mount-submodule">restas:mount-submodule</a>. Пример (зависит от кода выше):</p>
<p><div class="code"><span class="paren1">(<span class=""><i><span class="symbol">restas:define-module</span></i> <span class="keyword">#:test</span><br>&nbsp;&nbsp;<span class="paren2">(<span class=""><span class="keyword">:use</span> <span class="keyword">#:cl</span></span>)</span></span>)</span><br><br>
<span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_in_pkg.htm" class="symbol">in-package</a> <span class="keyword">#:test</span></span>)</span><br><br>
<span class="paren1">(<span class="">restas:mount-submodule test-hello-world <span class="paren2">(<span class=""><span class="keyword">#:hello-world</span></span>)</span></span>)</span><br><br>
<span class="paren1">(<span class="">restas:start '<span class="keyword">#:test</span> <span class="keyword">:port</span> 8080</span>)</span></div></p>
<p>В данном примере определяется новый модуль test, к нему присоединяется определённый выше модуль hello-world (а получившийся подмодуль ассоциируется с символом test-hello-world) и модуль test запускается на порту 8080. Хотя в самом модуле test не определён ни один маршрут, но в итоге он способен обрабатывать запросы, поступающие на /hello благодаря включению в себя модуля hello-world.</p>
<p>В таком виде данный функционал не выглядит очень полезным и вот почему. Для успешного повторного использования любого компонента надо уметь его конфигурировать, настраивать его параметры - без этой возможности повторное использование сведётся к технике copy/paste с последующим редактированием кода, что выглядит удручающее само по себе, а в контексте CL ещё имеет и множество технических ограничений (что связано с тем, что понятие пакета никак не связано с физическим размещением кода на файловой системе). В ООП традиционным способом решения проблем конфигурации является использование классов, но, хотя Common Lisp и имеет сверхмощную поддержку ООП (CLOS + MOP), я решил всё-таки отказаться от подобного подхода: возникающие проблемы дизайна, проектирования, бесконечные интерфейсы и наследование всегда существенным образом повышают уровень сложности системы, что кажется мне совершенно излишним для такой простой области, как разработка web-приложений. Для решения этой проблемы в Common Lisp есть ещё один потрясающий механизм: динамические переменные. Вот пример настоящего кода, используемого на <a class="reference" href="http://lisper.ru/"><span>lisper.ru</span></a> для публикации статических файлов:</p>
<p><div class="code"><span class="paren1">(<span class="">restas:mount-submodule rulisp-static <span class="paren2">(<span class=""><span class="keyword">#:restas.directory-publisher</span></span>)</span><br>&nbsp;&nbsp;<span class="paren2">(<span class=""><span class="special">restas.directory-publisher:*directory*</span> <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_merge_.htm" class="symbol">merge-pathnames</a> <span class="string">"static/"</span> <span class="special">*resources-dir*</span></span>)</span></span>)</span><br>&nbsp;&nbsp;<span class="paren2">(<span class=""><span class="special">restas.directory-publisher:*autoindex*</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_nil.htm" class="symbol">nil</a></span>)</span></span>)</span></div></p>
<p>В данном примере используется модуль <a class="reference" href="http://github.com/archimag/restas-directory-publisher"><span>restas-directory-publisher</span></a>.</p>
<p>В модуле  определены (с помощью <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defpar.htm" class="common-lisp-entity">defparameter</a> или <a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defpar.htm" class="common-lisp-entity">defvar</a>) несколько глобальных динамических переменных, которые можно использоваться для настройки его работы. В макросе  некоторые из этих переменных связываются c новыми значения, но эти связывания не применяются непосредственно, а сохраняются в виде контекста для использования в будущем. При обработке запроса диспетчер находит маршрут, определяет связанный с ним подмодуль, настраивает окружение на основе сохранённого контекста и производит дальнейшую обработку запроса в рамках этого окружения (для этого используется вызов <a href="http://www.lispworks.com/reference/HyperSpec/Body/s_progv.htm" class="common-lisp-entity">progv</a>). Данный механизм напоминает Buffer-Local Variables в Emacs.</p>
<p>При определении нового модуля с помощью <a class="common-lisp-entity" href="../ref/index.html#restas-define-module">restas:define-module</a> в него (в <a href="http://www.lispworks.com/reference/HyperSpec/Body/t_pkg.htm" class="common-lisp-entity">package</a>) добавляется переменная <span class="common-lisp-entity">*baseurl*</span>, которая должна быть списком строк и определяет базовый url, по которому будет активизирован данный модуль, по-умолчанию она установленная в <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_nil.htm" class="common-lisp-entity">nil</a>. Данную переменную можно использовать в <a class="common-lisp-entity" href="../ref/index.html#restas-mount-submodule">restas:mount-submodule</a> для задания url, по которому будет подключён подмодуль. Вот более сложный пример использования модуля <a class="reference" href="http://github.com/archimag/restas-directory-publisher"><span>restas-directory-publisher</span></a> на сайте <a class="reference" href="http://lisper.ru/"><span>lisper.ru</span></a> (посмотреть этот код в работе можно по адресу <a class="reference" href="http://lisper.ru/files/"><span>http://lisper.ru/files/</span></a>):</p>
<p><div class="code"><span class="paren1">(<span class="">restas:mount-submodule rulisp-files <span class="paren2">(<span class=""><span class="keyword">#:restas.directory-publisher</span></span>)</span><br>&nbsp;&nbsp;<span class="paren2">(<span class=""><span class="special">restas.directory-publisher:*baseurl*</span> '<span class="paren3">(<span class=""><span class="string">"files"</span></span>)</span></span>)</span><br>&nbsp;&nbsp;<span class="paren2">(<span class=""><span class="special">restas.directory-publisher:*directory*</span> <span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_merge_.htm" class="symbol">merge-pathnames</a> <span class="string">"files/"</span> <span class="special">*vardir*</span></span>)</span></span>)</span><br>&nbsp;&nbsp;<span class="paren2">(<span class=""><span class="special">restas.directory-publisher:*autoindex-template*</span><br>&nbsp;&nbsp;&nbsp;<span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_lambda.htm" class="symbol"><i><span class="symbol">lambda</span></i></a> <span class="paren4">(<span class="">data</span>)</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="paren4">(<span class="">rulisp-finalize-page <span class="keyword">:title</span> <span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_getf.htm" class="symbol">getf</a> data <span class="keyword">:title</span></span>)</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">:css</span> '<span class="paren5">(<span class=""><span class="string">"style.css"</span> <span class="string">"autoindex.css"</span></span>)</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">:content</span> <span class="paren5">(<span class="">restas.directory-publisher.view:autoindex-content data</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></div></p>
<p>Кстати, вкупе с предыдущим, данный пример показывает двукратное использование одного модуля с различными режимами работы в рамках одного и того же сайта, без каких-либо конфликтов между собой.</p>
</div>
<div id="внутренняя-инициализация" class="section"><h2>Внутренняя инициализация<a href="#внутренняя-инициализация" class="headerlink" title="Permalink to this headline">¶</a></h2><p>Макрос <a class="common-lisp-entity" href="../ref/index.html#restas-mount-submodule">restas:mount-submodule</a> позволяет контролировать настройку модуля "снаружи", но порой надо иметь возможность влиять на создаваемый контекст изнутри модуля. Например, модуль <a class="reference" href="http://github.com/archimag/restas-planet"><span>restas-planet</span></a>, который используется для организации <a class="reference" href="http://lisper.ru/planet/"><span>Russian Lisp Planet</span></a> нуждается в механизме для сохранения объекта-робота (он по заданному расписанию считывает ленты и объединяет их в одну), который должен быть вычислен на основе переменных, которые могут быть помещены в контекст submodule. Для такого случая предусмотрена generic-функция <span class="common-lisp-entity">restas:define-initialization</span>, вот реальный код из planet.lisp:</p>
<p><div class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defmet.htm" class="symbol"><i><span class="symbol">defmethod</span></i></a> restas:initialize-module-instance <span class="keyword">:before</span> <span class="paren2">(<span class=""><span class="paren3">(<span class="">module <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_eql.htm" class="symbol">eql</a> #.*package*</span>)</span></span>)</span> context</span>)</span><br>&nbsp;&nbsp;<span class="paren2">(<span class=""><i><span class="symbol">restas:with-context</span></i> context<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_when_.htm" class="symbol">when</a> <span class="special">*feeds*</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="paren4">(<span class="">restas:context-add-variable<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;context<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'<span class="special">*spider*</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="paren5">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_mk_ins.htm" class="symbol">make-instance</a> 'spider<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">:feeds</span> <span class="special">*feeds*</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">:schedule</span> <span class="special">*schedule*</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">:cache-dir</span> <span class="paren6">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_if.htm" class="symbol"><i><span class="symbol">if</span></i></a> <span class="special">*cache-dir*</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_ensu_1.htm" class="symbol">ensure-directories-exist</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/f_merge_.htm" class="symbol">merge-pathnames</a> <span class="string">"spider/"</span> <span class="special">*cache-dir*</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></div></p>
<p>Здесь производится вычисление объекта spider, который ассоциируется с переменной <span class="common-lisp-entity">*spider*</span> и помещается в контекст создаваемого submodule. Данный код будет вычислен при вычислении формы <a class="common-lisp-entity" href="../ref/index.html#restas-mount-submodule">restas:mount-submodule</a>. Поскольку создание объекта spider приводит к запуску планировщика (в частности, создаётся таймер), то также надо уметь останавливать их при повторном вычислении формы <a class="common-lisp-entity" href="../ref/index.html#restas-mount-submodule">restas:mount-submodule</a>, для этого предусмотрена generic-функция <span class="common-lisp-entity">finalize-module-instance</span></p>
<p><div class="code"><span class="paren1">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_defmet.htm" class="symbol"><i><span class="symbol">defmethod</span></i></a> restas:finalize-module-instance <span class="keyword">:after</span> <span class="paren2">(<span class=""><span class="paren3">(<span class="">module <span class="paren4">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/a_eql.htm" class="symbol">eql</a> #.*package*</span>)</span></span>)</span> context</span>)</span><br>&nbsp;&nbsp;<span class="paren2">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/s_let_l.htm" class="symbol"><i><span class="symbol">let</span></i></a> <span class="paren3">(<span class=""><span class="paren4">(<span class="">spider <span class="paren5">(<span class="">restas:context-symbol-value context '<span class="special">*spider*</span></span>)</span></span>)</span></span>)</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="paren3">(<span class=""><a href="http://www.lispworks.com/reference/HyperSpec/Body/m_when_.htm" class="symbol">when</a> spider<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="paren4">(<span class="">spider-stop-scheduler spider</span>)</span></span>)</span></span>)</span></span>)</span></div></p>
</div>
<div id="дуализм" class="section"><h2>Дуализм<a href="#дуализм" class="headerlink" title="Permalink to this headline">¶</a></h2><p>Описанная схема подразумевает дуализм: модуль как standalone-приложение, и он же как компонент повторного использования, что позволяет разрабатывать модуль без какого-либо учёта возможности повторного использования, а потом минимальной ценой (просто приводя его к "правильному" дизайну) превращать в многократно используемый компонент. Подобный подход, как мне кажется, позволяет в значительной степени избежать проблем, свойственных традиционному ООП-дизайну.</p>
<p>В качестве демонстрации, вот код для запуска <a class="reference" href="http://github.com/archimag/restas-directory-publisher"><span>restas-directory-publisher</span></a>, который я использовал выше как повторно используемый компонент, в виде standalone-приложения:</p>
<p><div class="code"><span class="paren1">(<span class="">restas:start '<span class="keyword">#:restas.directory-publisher</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">:port</span> 8080<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">:context</span> <span class="paren2">(<span class="">restas:make-context <span class="paren3">(<span class=""><span class="special">restas.directory-publisher:*baseurl*</span> '<span class="paren4">(<span class=""><span class="string">"tmp"</span></span>)</span></span>)</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="paren3">(<span class=""><span class="special">restas.directory-publisher:*directory*</span> #P<span class="string">"/tmp/"</span></span>)</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="paren3">(<span class=""><span class="special">restas.directory-publisher:*autoindex*</span> <a href="http://www.lispworks.com/reference/HyperSpec/Body/a_t.htm" class="symbol">t</a></span>)</span></span>)</span></span>)</span></div></p>
<p>Теперь открыв в браузере страницу <a class="reference" href="http://localhost:8080/tmp/"><span>http://localhost:8080/tmp/</span></a> можно будет наблюдать содержимое директории #P"/tmp/".</p>
</div>
</div> </div> </div> <div class="bottom">@2009-2011 <a href="mailto:archimag@gmail.com">Moskvitin Andrey</a></div> </body> </html>