Маршруты
========

Routes является ключевой концепцией RESTAS, собственно, с них и началась
разработка системы. Первоначально, идею routes, в более упрощённом виде,
я придумал самостоятельно, когда разрабатывал REST-службу для одного приложения.
Это был мой первый опыт web-разработки и я ничего не знал о других системах
(моё приложение изначально было реализовано на C++ как модуль для веб-сервера
Apache, а в последующем переписано на Python под mod_python). По мере моего
знакомства в веб-технологиями я узнал, что "придуманная" мной система
диспетчеризации называется routes и, насколько я понимаю, впервые появилась
в `Ruby On Rails`_. Если вы не знакомы с данной концепцией, то могу порекомендовать
следующее описание (Python-реализация): http://routes.groovie.org/manual.html.
Другой, концептуально очень близкой системой, является `URLConf`_ в `Django`_.

Когда я стал использовать Common Lisp для разработки web-приложений, то больше
всего меня расстраивала система диспетчеризации запросов web-сервер Hunchentoot,
точнее фактическое её отсутствие (а входящий в поставку define-easy-handler просто
ужасен). Для решения данной проблемы я решил написать `cl-routes`_: реализацию
системы маршрутов для Common Lisp, но без привязки к модели MVC. Первоначально
я планировал портировать Python-реализацию этой идеи на Common Lisp и принялся
изучать её исходный код. Первое, что меня смутило - размер исходного кода, слишком
много букв... А второе меня так просто добило: все маршруты транслируются в
регулярные выражения и при обработке запроса идёт простой перебор всех выражений
до первого совпадения. Брр... Фактически, системы маршрутизации `Ruby On Rails`_ и
`Django`_ работают точно так же, поиск ведётся прямым перебором. В документации к
`Django`_ написано про производительность буквально следующее:

  Each regular expression in a urlpatterns is compiled the first time it's accessed. This makes the system blazingly fast.

ага, как же, если количество маршрутов будет исчисляться сотнями или даже тысячами
(что вполне реалистично для больших приложений), то такая реализация может легко
стать главным тормозом всего приложения. И между прочим эта проблема достаточно
хорошо известна в RoR, где предлагаются различные пути для увеличения
производительности готовых приложений за счёт отказа от многих преимуществ маршрутов
и увеличения нагрузки на разработчиков. В Django, в общем, есть кое-какие пути для
увеличения производительности (за счёт задания префиксов на группы) (я правда не знаю,
повышает ли это реально производительность или нет, но принципиально может), но это
опять таки ведёт к увеличении нагрузки на программиста и не всегда может быть применено.

В общем, к существующим системам у меня есть две основные претензии:

* Использование универсального и тяжеловесного механизма регулярных выражений,
  который просто не нужен для разбора url
  
* Поиск в линейном списке (с некоторыми оговорками для Python-систем) - ведь структура
  сайта обычно естественным образом отображается в виде дерева, а значит возможен и
  более эффективен (чем больше сайт, тем более эффективен) поиск в дереве
  
`cl-routes`_ не используют регулярных выражений (вместо этого используется механизм
унификации), и компилирует все маршруты в одно дерево, что предоставляет
возможность более эффективного поиска. При задании маршрутов всегда возможны
конфликты, когда один и тот же url соответствует нескольким шаблонам. В системах
с последовательным поиском подходящего маршрута всегда выбирается первый,
`cl-routes`_ пытается выбрать наиболее специальный, например тот, в котором больше
переменных, или который имеет более длинную статическую часть. Точного описания
алгоритма разрешения коллизий пока дать не могу, но у меня до сих не было с этим
никаких проблем, поведение системы вполне разумно и по большей части соответствует
интуитивным ожиданиям.

Кроме того, что в `Ruby On Rails`_, что в `Django`_ для внесения изменений в схему
диспетчеризации необходимо внести изменения в несколько файлов, я же предпочитаю
держать определение схемы url и её обработчик в одном месте, не размазывая логику по
разным частям программы. В RESTAS задать новый маршрут можно так:

.. code-block:: common-lisp

  (restas:define-route article ("articles/:author/:item"
                                :method :get
                                :content-type "text/plain")
    (format nil "Author: ~A~Article: ~A" author item))
  
Т.е. в одном месте задаётся и шаблон url, и обработчик, при этом в теле обработчик
сразу же доступны переменные, заданные в шаблоне url. Вложенный обработчик,
по-умолчанию, может вернуть строку или "octets array", либо целое число (которое
интерпретируется как код статуса ответа), либо pathname (в этом случае вызывается
hunchentoot:handle-static-file, которая, в отличие от систем на базе Ruby или
Python работает достаточно быстро и реальной необходимости в дополнительных серверах
для "статики", таких как ngix, просто нет). Также, легко можно добавить поддержку
и обработку любых типов возвращаемых объектов.

При определении маршрута через define-route необходимо указать символ (в приведённом
примере - 'article), который будет являться его именем. Во-первых, это даёт
возможность в любой момент переопределить маршрут (в том числе и шаблон url, лишь
бы имя оставалось неизменным) простой отправкой кода в REPL (например, с помощью
M-C-x в SLIME). Во-вторых, это позволяет использовать данный символ для генерации url:

.. code-block:: common-lisp

  (restas:genurl 'article
                 :author "archimag"
                 :item "introduction-in-routes")

или для перенаправления:

.. code-block:: common-lisp

  (restas:redirect 'article
                   :author "archimag"
                   :item "introduction-in-routes")
                   
(возможны и другие использования)

В `Django`_ шаблон url задаётся регулярным выражением и возможности сопоставить
одному и тому же регулярному выражению несколько различных обработчиков (например,
для различных типов запроса: get, post и т.п.) нет, в `cl-routes`_ маршрут это
объект класса (либо производный от него) routes:route, для которого можно переопределить
метод route-check-conditions, что позволяет проводить диспетчеризацию не только на
основе шаблона url. Это используется в RESTAS и позволяет одному и тому же шаблону url
сопоставить несколько обработчиков, например, для разных типов (get, post и т.п.) запросов
(что позволяет сократить количество if-лапши в коде). 

Вот несколько возможных шаблонов url:
::

  /forum/:chapter/:topic/:message
  /forum/archives/:year/:month/:day
  /forum/:chapter/rss

Или с объединением строк:
::

  /book/:(name)-:(chapter).html
  /:(feed).:(format)

Также поддерживаются wildcard-параметры (с тем ограничением, что такой параметр
может использоваться в шаблоне только один раз):
::

  /mydoc/*items
  /*path/rss

.. _cl-routes: http://github.com/archimag/cl-routes

.. _Ruby On Rails: http://rubyonrails.org/
.. _Django: http://www.djangoproject.com/
.. _URLConf: http://docs.djangoproject.com/en/dev/topics/http/urls/
