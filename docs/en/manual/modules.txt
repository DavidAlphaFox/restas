.. _manual-modules:

Modules
=======

Module
------

From the Common Lisp point of view a module is just a :hs:`package`. From the
RESTAS point of view a module is a set of routes defining web application
structure. Module is created with macro :macro:`restas:define-module`
which creates a package with corresponding name and also makes some
additional initialization of it. For example:

.. code-block:: common-lisp

  (restas:define-module #:hello-world
    (:use #:cl))

Now you can create several routes in this module:

.. code-block:: common-lisp
 
  (in-package #:hello-world)

  (restas:define-route main ("hello")
    "<h1>Hello world!</h1>")

I should point out the principial importancy of macroexpansion of
:macro:`restas:define-route` in package (after :hs:`in-package`), bound
to certain module.

At last, obtained module can be launched as a site:

.. code-block:: common-lisp

  (restas:start '#:hello-world :port 8080)

You can also pass the :hostname keyword parameter to the function :fun:`restas:start`
which lets you serve several virtual hosts within one process.

Thus, after placing several routes in a module you can use the module for 
launching of a web application. But also there is another way of using modules.

Submodules
----------

Modules propose interesting way of repeated code usage for web application development.
The difference of a web component from an usual library containing functions, macros,
classes and other shuff is that web component also must contain information about
served urls and this information must be used by request dispatch mechanism and
rightly determine code responsible for processing incoming request. In the terms
of routes every repeatedly used web component is just a list of routes processed
by it, and this is just what modules are from the RESTAS point of view. For
repeated use of a module from other module one can use :macro:`restas:define-submodule`
macro. Example (depens on code above):

.. code-block:: common-lisp

  (restas:define-module #:test
    (:use #:cl))

  (in-package #:test)

  (restas:define-submodule test-hello-world (#:hello-world))

  (restas:start '#:test :port 8080)

In the given example we defined new module test and attached defined abouve module
hello-world to it (resulting submodule is assosiated with symbol test-hello-world)
and module test was started at 8080 port. Inspite of inside the 'test' module itself
no route is defined, in the end it is able to process requests coming to /hello
due to inclusion in inself hellow-word module.

In this state this functionality doesn't look very usable and this a reason to that.
For successful repeted use of any component you shoud know how to configure it,
tune its parameters, without this possibility repeted usage will boil down to
copy/paste technique with editing code after it, this looks depressing in itself
and in the context of CL aso has many technical limitations (this is concened with
the notion of package is in no way connected with physical code placement in file
system). In OOP the traditional way of solving configuration problems is the usage
of classes, but, despite of Common Lisp having superpower support for OOP (CLOS +
MOP), though I desided to reject this approach: appearing problems of design,
drafting, numberless interfaces and inheritance do always essentially raise
of system difficulty, and this look for me like a comletely excessive for such
a simple domain as web application development. For solution of this problem Common
Lisp has one more tremendous mechamism: dynamic variables. Here is an emple of code
used by `lisper.ru`_ for publishing of static files:

.. code-block:: common-lisp

  (restas:define-submodule rulisp-static (#:restas.directory-publisher)
    (restas.directory-publisher:*directory* (merge-pathnames "static/" *resources-dir*))
    (restas.directory-publisher:*autoindex* nil))

In this example we use `restas-directory-publisher`_ moudle.

In the module :package:`restas.directory-publisher` several global dynamic
variables are defined (with :hs:`defparameter` or :hs:`defvar`) which can
be used for customisation of its operation. In the macro 
:marcro:`restas:define-submodule` some of this variables are bound to new 
values but this bindings are not applied directly but saved as a context 
for future use. When processing a request dispatcher find a route, identifies
the moudle bound to it, adjusts environment on the basis of the saved contest
and makes later processing of request inside this environment (using special
operator :hs:`progv`). This mechanism resemles Buffer-Local Variables in
Emacs.

When defining a new module with :macro:`restas:define-module` the
:var:`*baseurl*` variable is added to it (to its :hs:`package`), the variable should
be a list of string and define a base url to activate the module, it is set to
:hs:`nil` by default. Given variable can be used in :macro:`restas:define-submodule`
for definiton of an url to plug in a module. Here is a more complex example of 
module `restas-directory-publisher`_ of the `lisper.ru`_ site (you can see it in
action at address http://lisper.ru/files/).

.. code-block:: common-lisp

  (restas:define-submodule rulisp-files (#:restas.directory-publisher)
    (restas.directory-publisher:*baseurl* '("files"))
    (restas.directory-publisher:*directory* (merge-pathnames "files/" *vardir*))
    (restas.directory-publisher:*autoindex-template*
     (lambda (data)
       (rulisp-finalize-page :title (getf data :title)
                             :css '("style.css" "autoindex.css")
                             :content (restas.directory-publisher.view:autoindex-content data)))))

Besides this, coupled to preceding example show double usage of the same 
module with different operation modes within the bounds of the same site
without any conflicts beetween them.

Internal dispatching
--------------------

:macro:`restas:define-submodule` macro lets you control module customisation
"from outside", but sometimes you need the possibility to control created context
inside the module. E.g. module `restas-planet`_ used for organizing of
`Russian Lisp Planet`_ requires a mechanism to save robot object (which, 
according to schedule, reads ribbons and merges them to single one), which
should be computed on the basis of variable which can be placed in submodule's
context. For such cases a :macro:`restas:define-initialization` macro is
provided, and here is the real code from planet.lisp:

.. code-block:: common-lisp

  (restas:define-initialization (context)
    (restas:with-context context
      (when *feeds*
        (restas:context-add-variable
          context
          '*spider*
          (make-instance 'spider
                         :feeds *feeds*
                         :schedule *schedule*
                         :cache-dir (if *cache-dir*
                                        (ensure-directories-exist
                                          (merge-pathnames "spider/" *cache-dir*))))))))

Here the computation of 'spider' object is made and the object is associated 
with variable :var:`*spider*` and is placed in the context of created submodule.
The present code will be evaluted during evaluation of :macro:`restas:define-submodule`
form. Considering that creation of spider object leads to launching of a scheduler
(in particular, a timer is created) we need to know how to stop it when evaluating 
:macro:`restas:define-submodule` in the second time. The macro
:macro:`restas:define-finalization` is provided for this.

.. code-block:: common-lisp

  (restas:define-finalization (context)
    (let ((spider (restas:context-symbol-value context '*spider*)))
      (when spider
        (spider-stop-scheduler spider))))

Dualism
-------

Described scheme impies a dualism: a module as a standalone application and 
the same module as a component for repeted usage, this lets developing a
module without taking in account any possibility of repeted usaga, and 
after that turing it into repeatedly use componet at minimal costs (just
by bringing it to the "right" design). Such approach, as I think, lets
in many cases escape from problems immanent to traditional OOP design.

As a demonstration, here is the code for launching `restas-directory-publisher`_,
which I used above as a repetedly used component, as a standalone application:

.. code-block:: common-lisp

  (restas:start '#:restas.directory-publisher 
                :port 8080 
                :context (restas:make-context (restas.directory-publisher:*baseurl* '("tmp"))
                                              (restas.directory-publisher:*directory* #P"/tmp/")
                                              (restas.directory-publisher:*autoindex* t)))

Now if you open in your browser the page http://localhost:8080/tmp/ you can
observe the content of the #P"/tmp/" directory.


.. _RESTAS: http://restas.lisper.ru/
.. _restas-directory-publisher: http://github.com/archimag/restas-directory-publisher
.. _restas-planet: http://github.com/archimag/restas-planet
.. _lisper.ru: http://lisper.ru/
.. _Russian Lisp Planet: http://lisper.ru/planet/
