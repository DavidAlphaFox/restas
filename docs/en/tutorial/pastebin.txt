.. -*- RST -*-

.. _tutorial-pastebin:

==========
 Pastebin
==========

As a demonstration of using `RESTAS`_ for creation of full featured 
web application I want to show how you can build a simpliest pastebin service.

В качестве демонстрации использования `RESTAS`_ для создания полноценного
веб-приложения я хочу показать, как можно построить простейший pastebin-сервис.

.. note:: Note
.. note:: Примечание

  From `Wikipedia <http://ru.wikipedia.org/wiki/Pastebin>`_:
  A pastebin is a web application which allows its users to upload snippets
  of text, usually samples of source code, for public viewing. It is very
  popular in IRC  channels where pasting large amounts of text is considered
  bad etiquette. A vast number of pastebins exist on the Internet, suiting
  a number of different needs and provided features tailored towards
  the crowd they focus on most.
  
Pastebin is a very simple application, however with this example I can show 
the basic principles of building `RESTAS`_ applications. Apart from this,
it is a real application used by `lisper.ru`_ site.
You can see it in action `here <http://lisper.ru/apps/format/>`_.

Pastebin - это очень простое приложение, на примере которого, однако, можно показать
основные принципы построения `RESTAS`_-приложений. Кроме того, это реальное
приложение, которое используется на сайте `lisper.ru`_, 
попробовать его в работе можно `здесь <http://lisper.ru/apps/format/>`_.

This component must have the following abilities:
Данный компонент должен обладать следующими функциональными возможностями:

* A form for creation of new element.
* Форма для создания нового элемента

* List of all registered elements, with transition viewing them after clicking
  on them.
* Список всех зарегистрированных элементов, щелчком на которых можно выполнить
  переход к просмотру этих элементов

* View for displaying every element.
* Представление для просмотра каждого элемента

* Syntax highlight.
* Подсветка синтаксиса 

Apart from this, pastebin is aimed for using in a contex of different sites and
hereby must have flexible means of configuration:
Кроме того, он предназначен для использования в составе различных сайтов и таким
образом должен обладать гибкими возможностями по конфигурации:

* Use the athentification system used by the site.
* Использовать предоставляемую сайтом систему аутентификации

* Use the data storage, provided by the site.
* Использовать предоставляемое сайтом хранилище данных

* Provide customisation for way of rendering pages.
* Предусматривать настройку способа отображения страниц

Logical structure
Логическая структура
====================

This application is built with classical MVC model and has distinct
sepatation of model, controller, and view.

Данное приложение построено на основе классической модели MVC, с чётким
разделением модели, контролёра и представления.

Customisation of the module is done with special (dynamic) variables
(for details about customisation of modules with dynamic variables
see section :ref:`manual-modules`).

Настройка модуля производиться через `специальные <http://lisper.ru/articles/cl-vars>`_
(динамические) переменные (подробнее о настройке модулей с помощью динамических
переменных смотрите раздел :ref:`manual-modules`).

You can store data of this application in a number of ways, so we define
needed interface and special variable :fun:`*storage*`, with aid of which
an outside application can specify used way of data storage. For development
and debugging one needs to have a functioning model, which is implemented
by trivial class :class:`memory-storage` providing a way of storing data
in the memory, such approach lets you develop the application without
any accent on the structure of database and imtroduce such stucture only
if you really need it.

Хранить данные этого приложения можно множеством различных способов, поэтому
определяется необходимый интерфейс и специальная переменная :fun:`*storage*`,
с помощью которой внешнее приложение сможет указать используемый способ хранения
данных. Для разработки и отладки нужно иметь функционирующую модель, которая
реализуется тривиальным классом :class:`memory-storage`, который обеспечивает
хранения необходимых данных в памяти - такой подход позволяет вести разработку
не акцентируя внимание на структуре базы данных, а вводить её только при
реальной необходимости.

Usually sites have unified authentification scheme which should be used in
all its components. Therefore the component under development shouldn't
know anything about used authentification scheme. In fact, for proper
functioning it needs to know only user's name. Consequently, it is enough
to introduce just one special variable :var:`*colorize-user-function*`
that will store a function for fuguring out user's name.

Обычно сайты имеют единую схему аутентификации, которая должна использоваться во
всех компонентах. Поэтому разрабатываемый компонент не должен ничего знать об
используемой схеме аутентификации. Фактически, для его функционирования ему
необходимо знать только имя пользователя. Поэтому достаточно ввести одну
единственную специальную переменную :var:`*colorize-user-function*`, в которой
будет храниться функция, вычисляющая имя пользователя. 

For providing flexible customisation of page view by the component for
separation of logic and view we use special variable
:var:`*default-render-method*` created by `RESTAS`_ and storing the object
in charge of representaion (in more details you will find it in section
:ref:`manual-view`). And for defining page templates we use
`cl-closure-template`_ library.

Что бы компонент допускал гибкую настройку отображения страниц для отделения
логики представления используется создаваемая `RESTAS`_ специальная переменная
:var:`*default-render-method*`, в которой храниться объект, ответственный за
представление (подробнее об этом смотрите в разделе :ref:`manual-view`). А для
определения шаблонов страниц используется библиотека `cl-closure-template`_.
 
Physical structure
Физическая структура
====================

To simplify understanding of the code structute following division to files is
used:
Для упрощения понимания структуры кода используется следующее разбиение на файлы:

* **defmodule.lisp** - contains defenition of the module and also special variables
  for controlling the behavior of the component.
* **defmodule.lisp** - содержит определение модуля, а также специальных переменных,
  с помощью которых можно будет настроить поведение компонента

* **storage.lisp** - contains definition of interface for used data model and 
  a simple implementation of this model.
* **storage.lisp** - содержит определения интерфейса, которому должна удовлетворять
  используемая модель данных, а также простейшую реализацию этой модели.

* **drawer.lisp** - interface and implementation of default drawer object to be used
  for setting the value of :var:`*default-render-method*` special variable.
* **drawer.lisp** - интерфейс и реализация по-умолчанию объекта drawer, который будет
  использоваться для установки значения специальной переменной :var:`*default-render-method*`

* **drawer.tmpl** - file with templates in `cl-closure-template`_ format
* **drawer.tmpl** - файл с шаблонами в формате `cl-closure-template`_

* **routes.lisp** - the central part of the application in which URL scheme and 
  request handlers are defined.
* **routes.lisp** - центральная часть приложения, в которой определяется схема URL и код
  для обработки поступающих запросов

Implementation
Реализация
==========

defmodule.lisp
--------------

.. code-block:: common-lisp

  (restas:define-module #:restas.colorize
    (:use #:cl #:iter)
    (:export ..))

  (in-package #:restas.colorize)

  (defvar *max-on-page* 10)

  (defvar *storage* nil)

  (defvar *colorize-user-function* #'(lambda () "anonymous"))

  (defun colorize-user ()
    (if *colorize-user-function*
        (funcall *colorize-user-function*)))

Here we define new module **#:restas.colorize** (for saving space list of 
exported symbols is omited) and introduce several special variables
for using them in module customisation (varibles :var:`*max-on-page*`
and :var:`*colorize-user-function*` come with default values) and also
:fun:`colorize-user` helper function is defined for figuring out user name.

Здесь определяется новый модуль **#:restas.colorize** (при этом в целях экономии
места опущен список экспортируемых символов) и введено несколько специальных
переменных, которые будут использоваться для настройки модуля (для переменных
:var:`*max-on-page*` и :var:`*colorize-user-function*` определены значения
по-умолчанию), а также определена вспомогательная функция :fun:`colorize-user`,
которая будет вычислять имя пользователя.
  
storage.lisp
------------

Defenition of interface for :var:`*storage*` object to comply with:
Определение интерфейса, которому должен удовлетворять объект :var:`*storage*`:

.. code-block:: common-lisp

  (defgeneric storage-count-notes (storage)
    (:documentation "Колличество записей"))

  (defgeneric storage-list-notes (storage offset limit)
    (:documenation "Список записей начиная с offset, но колличеством не больше limit"))

  (defgeneric storage-get-note (storage id)
    (:documentation "Получить записть по id"))

  (defgeneric storage-add-note (storage note)
    (:documentation "Добавить новую запись"))

Helper class for storing information about one record:
Вспомогательный класс, для хранения информации об одной записи:

.. code-block:: common-lisp
    
  (defclass note ()
    ((id :initarg :id :initform nil :accessor note-id)
     (date :initarg :date :initform nil :accessor note-date)
     (author :initarg :author :initform nil :accessor note-author)
     (title :initarg :title :initform nil :accessor note-title)
     (lang :initarg :lang :initform nil :accessor note-lang)
     (code :initarg :code :initform nil :accessor note-code)))

Implementation of memory storage is trivial, so it's enough to site
just the class definition:
Реализация хранилища в памяти тривиальная, поэтому достаточно привести
только определением класса:

.. code-block:: common-lisp

  (defclass memory-storage ()
    ((notes :initform nil)
     (last-id :initform 0)))

Setting default value for :var:`*storage*` variable:
Установка переменной :var:`*storage*` значения по-умолчанию:

.. code-block:: common-lisp

  (setf *storage* (make-instance 'memory-storage))

routes.lisp
-----------

In this file, processed URL and opetation logic.
Because all logic of view is handled by :var:`*default-render-method*`
object, route handlers should just gather and preparare data for 
processing them with fucntion :fun:`restas:render-object`.
View logic, as I said before, is implimented on the basis of
`cl-closure-template`_ library which as input data format uses
*plist* (you can read about using *property list* in more details 
`here <http://lisper.ru/pcl/practical-a-simple-database>`_), so route handlers
generate data in this format.

В этом файле определяются обрабатываемые URL и управляющая логика.
Поскольку за всю логику представления отвечает объект :var:`*default-render-method*`,
то обработчики маршрутов должны только собирать и подготавливать данные,
которые после этого будут обрабатываться с помощью функции :fun:`restas:render-object`.
Логики представления, как сказано выше, реализуется на основе библиотеки
`cl-closure-template`_, которая в качестве входного формата данных использует
*plist* (подробнее об использовании *property list* можно прочитать
`здесь <http://lisper.ru/pcl/practical-a-simple-database>`_), поэтому обработчики
маршрутов генерируют данные в этом формате.

A couple of helper functions translating record information to *plist* format:

Пара вспомогательных функций, переводящих информацию о записи в формат *plist*:

.. code-block:: common-lisp

  (defun note-plist/short (note)
    (list :href (restas:genurl 'view-note :id (note-id note))
          :date (local-time:format-timestring nil (note-date note))
          :title (note-title note)
          :author (note-author note)))

  (defun note-plist (note)
    (list* :title (note-title note)
           :code (note-code note)
           :lang (note-lang note)
           (note-plist/short note)))

In this code, the following call is of the most interest:

В этом коде наибольший интерес представляет вызов

.. code-block:: common-lisp

  (restas:genurl 'view-note :id (note-id note))

It generates URL for viewing record basing on route name ('view-node) and :id
parameter.

Который генерирует URL для просмотра записи на основе имени маршрута ('view-node)
и параметра :id.

.. note:: None

  In route-based systems "manual" creation of URL is not a common practise,
  because automatic generation considerably increases flexebility of an 
  application and releaves you from many potential problems. Among other issues,
  in this cases the base URL will be taken in account which is address a module
  is plugged into and which is unknown at the module development stage.

  В системах на основе маршрутов не принято "ручное" создание URL, поскольку
  автоматическая генерация значительно повышает гибкость приложения и избавляет
  от многих потенциальных проблем. Помимо прочего в данном случае будет
  учтён базовый URL, по которому подключён модуль и который не известен на
  этапе разработки модуля.

Application entry point:

Точка входа в приложение:

.. code-block:: common-lisp

  (restas:define-route main ("")
    (restas:redirect 'list-notes))

This route sends request to base URL where the module is activated,
adn simply redirects to the page with record list. For redirection 
:fun:`restas:redirect` function is used which, like :fun:`restas:genurl`,
processes the name of route (and a set of parameters, but 'list-notes route
doesn't have them) so there is no need in actual specifying the URL.

Данный маршрут обрабатывает запрос к базовому URL, по которому подключён модуль,
и просто перенаправляет на страницу со списком записей. Для перенаправления
используется функция :fun:`restas:redirect`, которая, подобно :fun:`restas:genurl`,
обрабатывает имя маршрута (и набор параметров, но у маршрута 'list-notes их нет),
так что нет необходимости в явном указании URL.

For displaying record list a page-by-page representation is used with limiting
of number of records on a single page which mustn't be more than :var:`*max-on-page*`
(this variable was introduced in **defmodule.lisp**). So, apart from the record list
itself you need to gather information about overal number of records,
and also provide links to previous and next pages:

Для отображения списка записей используется постраничное отображение, с
ограничением количества записей на одной странице, которое не должно быть более
:var:`*max-on-page*` (эта переменная введена в **defmodule.lisp**). Поэтому,
кроме самого списка записей необходимо собрать информацию об общем количество записей,
а также предоставить ссылки на предыдущую и следующую страницы:

.. code-block:: common-lisp

  (restas:define-route list-notes ("all")
    (let* ((total-count (storage-count-notes *storage*))
           (start (min (max (or (ignore-errors (parse-integer (hunchentoot:get-parameter "start")))
                                1)
                            1)
                       total-count)))
      (list :title "All notes"
            :notes (iter (for note in (storage-list-notes *storage*
                                                          (1- start)
                                                          *max-on-page*))
                         (collect (note-plist/short note)))
            :first start
            :total-count total-count
            :href-before (if (< (+ (1- start) *max-on-page*)
                                total-count)
                             (format nil
                                     "~A?start=~A"
                                     (restas:genurl 'list-notes)
                                     (+ start *max-on-page*)))
            :href-after (if (> start 1)
                            (format nil
                                    "~A?start=~A"
                                    (restas:genurl 'list-notes)
                                    (max (- start *max-on-page*) 1))))))

The given code is kind of more entangled than it should be, by the reason that
the really processed URL looks like this

Данный код несколько более запутан, чем следовало бы, по той причине, что реально
обрабатываемый URL выглядит как
::

  all?start=n

(where n is sequential number of the first record on the page) and `RESTAS`_ 
route system yet doesn't know hot to take into account GET parameters of
request.

(где n это порядковый номер первой
записи на странице), а система маршрутов `RESTAS`_ пока не умеет учитывать
GET-параметры запроса. 

For viewing a particular record responds the following route:

За просмотр конкретной записи отвечает следующий маршрут:

.. code-block:: common-lisp

  (restas:define-route view-note (":id"
                                  :parse-vars (list :id #'parse-integer))
    (note-plist (storage-get-note *storage* id)))

This handler is very simple, but it contains one interesting moment, the 
:parse-vars parameter. The identifier of record is ID, which should be
an integer number. This code lets you ensure that specified URL contains 
namely integer number and converts it from the string representation, os
handler code already works with the integer value.

Данный обработчик очень прост, но содержит один любопытный момент - параметр
:parse-vars. Индефикатором записи является id, который должен быть целым числом.
Данный код позволяет убедиться, что указанный URL содержит именно целое число
и преобразует его из строкового представления, так что код обработчика работает
уже с целочисленным значением. 

Route for displaying form of creation of an record is yet more trivial:

Маршрут, отвечающий за показ формы создания записи ещё более тривиален:

.. code-block:: common-lisp

  (restas:define-route create-note ("create")
    (list :title "Создать"))

This form will support each of saving record and previewing it, therefore
for processing a POST request I used here two routes processing the same
URL: 

Данная форма будет поддерживать как сохранение записи, так и предварительный
просмотр, поэтому для обработки соответствующего POST-запроса я использую
два маршрута, обрабатывающих один и тот же URL:

.. code-block:: common-lisp

  (restas:define-route preview-note ("create"
                                     :method :post
                                     :requirement #'(lambda () (hunchentoot:post-parameter "preview")))
    (list :title (hunchentoot:post-parameter "title")
          :author (colorize-user)
          :code (hunchentoot:post-parameter "code")
          :lang (hunchentoot:post-parameter "lang")))


  (restas:define-route save-note ("create"
                                  :method :post
                                  :requirement #'(lambda () (hunchentoot:post-parameter "save")))
    (let ((author (colorize-user)))
      (if author
          (restas:redirect 'view-note
                           :id (note-id (storage-add-note
                                          *storage*
                                          (make-instance 'note
                                                         :code (hunchentoot:post-parameter "code")
                                                         :author author
                                                         :lang (hunchentoot:post-parameter "lang")
                                                         :title (hunchentoot:post-parameter "title")))))
          hunchentoot:+http-forbidden+)))

Selecting a route is done by :requirement property checking which command
(Save or Preview) was selected by a user. For checking whether a user has
the right to save the record :fun:`colorize-user` function is used (it was
defined in **defmodule.lisp**) and if the user doesn't authorised himself
then after a try to save a record he will get :const:`hunchentoot:+http-forbidden+`
status.

Для выбора маршрута используется свойство :requirement, в котором проверяется
какая команда (Save или Preview) была выбрана пользователем. Для проверки того,
что пользователь имеет ли право сохранять запись используется :fun:`colorize-user`
(которая была определена в **defmodule.lisp**) и если пользователь не авторизовался,
то на попытку сохранить запись он получит статус :const:`hunchentoot:+http-forbidden+`.

drawer.lisp
-----------

All routes defined above return data in the *plist* format, therefore
for selecting a template for processing passed data, in addition it is necessary
to use the name of the current route, which can be evaluated by

Все определённые выше маршруты возвращают данные в формате *plist*, поэтому
для выбора шаблона, который должен отображать переданные данные, необходимо 
дополнительно использовать имя текущего маршрута, которое можно вычислить как:

.. code-block:: common-lisp

  (restas:route-symbol restas:*route*)

and for this a generic method is defined:

и для этого определен generic-метод:

.. code-block:: common-lisp

  (defgeneric render-route-data (drawer data route )
    (:documentation "Отображение страницы для указанного маршрута"))

It can be specialized with *eql* qualifier for each particular route.

который можно будет специализировать с помощью квалификатора *eql* для каждого
конкретного маршрута.

In order to outside application could redefine the general theme of site
there is generic function:

Что бы внешнее приложение могло переопределить общую тему оформления
определяется generic-фукнция:

.. code-block:: common-lisp

  (defgeneric finalize-page (drawer data)
    (:documentation "Формирование итоговой страницы"))

For syntax highliting CL has `colorize`_ library, which highlights Common
Lisp code very good, but, frankly speaking, is far away from been ideal.
So, for leaving possibility to use other instrument, which will probably
arise in the future, the following interfaces are defined with default 
implementation on the basis of `colorize`_:

Для подсветки синтаксиса в CL есть библиотека `colorize`_, которая очень
хорошо подсвечивает код на Common Lisp, но, честно говоря, далека от
идеала. Поэтому, что бы оставить возможность использовать другой инструмент,
который, возможно, появится в будущем, определены следующие
интерфейсы с реализацией по-умолчанию на базе `colorize`_:

.. code-block:: common-lisp

  (defgeneric colorize (drawer code lang)
    (:documentation "Генерация html с подсветкой кода")
    (:method (drawer code lang)
      (colorize::html-colorization lang code)))

  (defgeneric colorize-langs (drawer)
    (:documentation "Список поддерживаемых языков")
    (:method (drawer)
      (iter (for (id . title) in (colorize:coloring-types))
            (collect (list :id (symbol-name id)
                           :title title)))))

For specializing the call to :fun:`restas:render-object` and also for 
implementation of defined interfaces we need class:

Для того, что бы специализировать вызов :fun:`restas:render-object`, а также
определить реализации объявленных интерфейсов нужен класс:

.. code-block:: common-lisp

  (defclass drawer () ())

Implementation of :fun:`finalize-page` by default just calls a template
with the same name:

Реализация :fun:`finalize-page` по-умолчанию просто вызывает одноименный шаблон:

.. code-block:: common-lisp

  (defmethod finalize-page ((drawer drawer) data)
    (restas.colorize.view:finalize-page data))

Now :fun:`restas:render-object` can be written in the following form:

Теперь :fun:`restas:render-object` записывается следующим образом:

.. code-block:: common-lisp

  (defmethod restas:render-object ((drawer drawer) (data list))
    (let ((content (render-route-data drawer
                                      data
                                      (restas:route-symbol restas:*route*)))
          (menu (restas.colorize.view:main-menu
                 (list :href-all  (restas:genurl 'list-notes)
                       :href-create (restas:genurl 'create-note)))))
      (finalize-page drawer
                     (list :content content
                           :menu menu
                           :title (getf data :title)))))

Here takes place a call to :fun:`finalize-page`, where the following data
is passed in *plist* format:

Здесь происходит вызов :fun:`finalize-page` куда в формате *plist* передаются
следующие данные:

* **content** - the basical content of page as generated by call to
  :fun:`render-route-data`

* **content** - основное содержимое страницы, которое генерируется с помощью
  вызова :fun:`render-route-data`

* **menu** - links for viewing records and creating a new record, used for
  displaying the common for all pages menu .

* **menu** - ссылки на просмотр записей и создание новой записи, которые
  используются для показа общего для всех страниц меню

* **title** - the heading of page extracted from passed data

* **title** - заголовок страницы, который извлекается из переданных данных

Implementation of :fun:`render-route-data` processes passed data with aid
of template, whose name matches the name of the passed route (here you can
find the using of well known "Prevailing of agreement over configuration"):

Реализация :fun:`render-route-data` обрабатывает переданные данные с помощью
шаблона, имя которого совпадет с именем переданного маршрута (здесь можно
обнаружить использование известного "примата соглашения над конфигурацией"):

.. code-block:: common-lisp

  (defmethod render-route-data ((drawer drawer) list route)
    (funcall (find-symbol (symbol-name route)
                          '#:restas.colorize.view)
             data))

Several routes need additional processing of passed data which can't be done
at the template side, this is done with *eql*-based specializing:

Для некоторых маршрутов необходима дополнительная обработка передаваемых данных,
которая не может быть выполнена на стороне шаблонов, это достигается за счёт
специализации на основе квалификатора *eql*:

.. code-block:: common-lisp

  (defmethod render-route-data ((drawer drawer) (data list) (route (eql 'view-note)))
    (call-next-method drawer
                      (list* :code (colorize drawer
                                             (getf data :code)
                                             (getf data :lang))
                             data)
                      route))

  (defmethod render-route-data ((drawer drawer) (data list) (route (eql 'create-note)))
    (call-next-method drawer
                      (list* :langs (colorize-langs drawer)
                             data)
                      route))

  (defmethod render-route-data ((drawer drawer) (data list) (route (eql 'preview-note)))
    (call-next-method drawer
                      (list* :langs (colorize-langs drawer)
                             :preview (colorize drawer
                                                (getf data :code)
                                                (getf data :lang))
                             data)
                      route))

Finally :var:`*default-render-method*` is assigned the default value:

Ну и наконец переменной :var:`*default-render-method*` присваивается
значение по-умолчанию:

.. code-block:: common-lisp

  (setf *default-render-method* (make-instance 'drawer))

Thereby for generation of a real content a complex system is used,
which, on the one hand is fully based on templates and on the other hand
each its aspect is defined as a generic function, so changing a way of representation
is is enough to define a drawer-inherited class and specialize required functions.

Таким образом, для генерации реального контента используется достаточно сложная схема,
которая с одной стороны полностью опирается на шаблоны, а с другой каждый её аспект
определён как generic-функция, так что для изменения способа отображения достаточно
определить класс, наследующий от :class:`drawer`, и специализировать нужные функции.

drawer.tmpl
-----------

Compilation of the templates file is done by code:

Компиляция файла c шаблонами производится кодом:

.. code-block:: common-lisp

  (defparameter *colorize-template-path*
    (merge-pathnames "src/drawer.tmpl"
                     (asdf:component-pathname (asdf:find-system '#:restas-colorize))))

  (closure-template:compile-template :common-lisp-backend
                                     *colorize-template-path*)

And the file itself has the following content:

А сам он имеет следующее содержание:
::

  {namespace restas.colorize.view}

  {template finalizePage}
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
      {\n}
      <html>
          <head>
      	      <meta http-equiv="Content-Type" content="text/html; charset='utf-8'" />

              {if $title}
                  <title>{$title}</title>
              {/if}
          </head>

          <body>
            {$menu |noAutoescape}
            
            {$content |noAutoescape}
          </body>
      </html>
  {/template}

  {template main-menu}
      <ul class="colorize-top-menu">
          <li>
              <a href="{$hrefAll}">Все записи</a>
          </li>

          <li>
              <a href="{$hrefCreate}">Создать</a>
          </li>
     </ul>
  {/template}

  {template show-note-info}
      <div class="info">
          Автор: <strong>{$author}</strong> - {$date}
      </div>
  {/template}
    
  {template list-notes}
      <div class="colorize-list-nav" >
          {if $hrefAfter}<a href="{$hrefAfter}">« Позже</a>{/if}
          {$first} - {min($first + length($notes) - 1, $totalCount)} 
          из {$totalCount}  
          {if $hrefBefore}<a href="{$hrefBefore}">Раньше »</a>{/if}
      </div>

      {foreach $note in $notes}
          <div class="note">
              <a href="{$note.href}">{$note.title != '' ? $note.title : '*notitle*'}</a>
              {call show-note-info data="$note" /}
          </div>
      {/foreach}
  {/template}

  {template view-note}
      <div class="note-detail">
          <strong>{$title}</strong>
          {call show-note-info data="all" /}
          <div class="code">
              {$code |noAutoescape}
          </div>
      </div>
  {/template}    
    
  {template create-note}
      <form method="post">
          <textarea rows="30" name="code" cols="80" style="width: 100%">{$code}</textarea>
          <table style="text-align: left">
              <tbody>
                  {if $preview and $author}
                      <tr>
                          <th>Описание:</th>
                          <td>
                              <input size="60" name="title" type="text" {if $title}value="{$title}"{/if}/>
                          </td>
                      </tr>
                  {/if}
                    
                  <tr>
                      <th>Форматировать как:</th>
                      <td>
                          <select name="lang" >
                              {foreach $l in $langs}
                                  <option {if $l.id == $lang}selected{/if} value="{$l.id}">{$l.title}</option>
                              {/foreach}
                          </select>
                      </td>
                  </tr>
              </tbody>
          </table>
        
          <input type="submit" value="Форматировать" name="preview" />
          {if $preview and $author}
              <input type="submit" value="Сохранить" name="save" />
          {/if}

          {if $preview}
              <h3>Предварительный просмотр</h3>
              <div class="code">
                  {$preview |noAutoescape}
              </div>
          {/if}
     </form>    
  {/template}

  {template preview-note}
      {call create-note data="all" /}
  {/template}

Usage

Использование
=============

For using the component described ealrier on the `lisper.ru`_ site I use
the following code:

Для использования описанного компонента на сайте `lisper.ru`_ я использую
следующий код:

.. code-block:: common-lisp

  (defclass pastebin-drawer (restas.colorize::drawer) ())

  (defmethod restas.colorize::finalize-page ((drawer pastebin-drawer) data)
    (rulisp-finalize-page  :title (getf data :title)
                           :css '("style.css" "colorize.css")
                           :content (concatenate 'string
                                                 (getf data :menu)
                                                 (getf data :content))))

  (restas:define-submodule rulisp-format (#:restas.colorize)
    (restas.colorize:*baseurl* '("apps" "format"))
    (restas.colorize:*max-on-page* 15)
    (restas.colorize:*storage* *rulisp-db-storage*)
    (restas.colorize:*colorize-user-function* #'compute-user-login-name)
    (restas.colorize:*default-render-method* (make-instance 'pastebin-drawer)))

Here are variables specified with dynamic variable binding:
the baseURL for activating the module, maximal number of records per page,
the way of storing the data, authentification mechanism, and also a correct
way of displaying for the commponent not to stay out of general design style.

Здесь через динамическое связывание специальных переменных задаётся базовый URL,
по которому подключается модуль, максимальное количество записей на странице,
способ хранения данных, способ аутентификации, а также корректируется способ
отображения, так что данный компонент не выбивается из общего стиля оформления.

Source code

Исходный код
============

The source code of described application is almost completely sited above and is
available at the address http://github.com/archimag/restas-colorize. Not taking in
account the temlate file, the size of the source code is about 200 lines.

Исходный код описанного приложения, который почти полностью приведён выше, доступен
по адресу http://github.com/archimag/restas-colorize. Без учёта файла шаблонов размер
исходного года - около 200 строк.

.. _RESTAS: http://restas.lisper.ru/
.. _lisper.ru: http://lisper.ru/
.. _cl-closure-template: http://code.google.com/p/cl-closure-template/
.. _colorize: http://www.cliki.net/colorize
