.. -*- RST -*-

.. _tutorial-pastebin:

==========
 Pastebin
==========

As a demonstration of using `RESTAS`_ for creation of full featured 
web application I want to show you how to build a simplest pastebin service.

.. note:: Note

  From `Wikipedia <http://ru.wikipedia.org/wiki/Pastebin>`_:
  A pastebin is a web application which allows its users to upload snippets
  of text, usually samples of source code, for public viewing. It is very
  popular in IRC  channels where pasting large amounts of text is considered
  bad etiquette. A vast number of pastebins exist on the Internet, suiting
  a number of different needs and provided features tailored towards
  the crowd they focus on most.
  
Pastebin is a very simple application, however with this example I can show 
the basic principles of building `RESTAS`_ applications. Apart from this,
it is a real application used by `lisper.ru`_ site.
You can see it in action `here <http://lisper.ru/apps/format/>`_.

This component must have the following abilities:

* A form for creation of new element.

* List of all registered elements, with transition viewing them after clicking
  on them.

* View for displaying every element.

* Syntax highlight.

Apart from this, pastebin is aimed for using in a contex of different sites and
hereby must have flexible means of configuration:

* Use the athentification system used by the site.

* Use the data storage, provided by the site.

* Provide customisation for way of rendering pages.

Logical structure
=================

This application is built with classical MVC model and has distinct
sepatation of model, controller, and view.

Customisation of the module is done with special (dynamic) variables
(for details about customisation of modules with dynamic variables
see section :ref:`manual-modules`).

You can store data of this application in a number of ways, so we define
needed interface and special variable :fun:`*storage*`, with aid of which
an outside application can specify used way of data storage. For development
and debugging one needs to have a functioning model, which is implemented
by trivial class :class:`memory-storage` providing a way of storing data
in the memory, such approach lets you develop the application without
any accent on the structure of database and imtroduce such stucture only
if you really need it.

Usually sites have unified authentification scheme which should be used in
all its components. Therefore the component under development shouldn't
know anything about used authentification scheme. In fact, for proper
functioning it needs to know only user's name. Consequently, it is enough
to introduce just one special variable :var:`*colorize-user-function*`
that will store a function for fuguring out user's name.

For providing flexible customisation of page view by the component for
separation of logic and view we use special variable
:var:`*default-render-method*` created by `RESTAS`_ and storing the object
in charge of representaion (in more details you will find it in section
:ref:`manual-view`). And for defining page templates we use
`cl-closure-template`_ library.
 
Physical structure
==================

To simplify understanding of the code structute following division to files is
used:

* **defmodule.lisp** - contains defenition of the module and also special variables
  for controlling the behavior of the component.

* **storage.lisp** - contains definition of interface for used data model and 
  a simple implementation of this model.

* **drawer.lisp** - interface and implementation of default drawer object to be used
  for setting the value of :var:`*default-render-method*` special variable.

* **drawer.tmpl** - file with templates in `cl-closure-template`_ format

* **routes.lisp** - the central part of the application in which URL scheme and 
  request handlers are defined.

Implementation
==============

defmodule.lisp
--------------

.. code-block:: common-lisp

  (restas:define-module #:restas.colorize
    (:use #:cl #:iter)
    (:export ..))

  (in-package #:restas.colorize)

  (defvar *max-on-page* 10)

  (defvar *storage* nil)

  (defvar *colorize-user-function* #'(lambda () "anonymous"))

  (defun colorize-user ()
    (if *colorize-user-function*
        (funcall *colorize-user-function*)))

Here we define new module **#:restas.colorize** (for saving space list of 
exported symbols is omited) and introduce several special variables
for using them in module customisation (varibles :var:`*max-on-page*`
and :var:`*colorize-user-function*` come with default values) and also
:fun:`colorize-user` helper function is defined for figuring out user name.
  
storage.lisp
------------

Defenition of interface for :var:`*storage*` object to comply with:

.. code-block:: common-lisp

  (defgeneric storage-count-notes (storage)
    (:documentation "Колличество записей"))

  (defgeneric storage-list-notes (storage offset limit)
    (:documenation "Список записей начиная с offset, но колличеством не больше limit"))

  (defgeneric storage-get-note (storage id)
    (:documentation "Получить записть по id"))

  (defgeneric storage-add-note (storage note)
    (:documentation "Добавить новую запись"))

Helper class for storing information about one record:

.. code-block:: common-lisp
    
  (defclass note ()
    ((id :initarg :id :initform nil :accessor note-id)
     (date :initarg :date :initform nil :accessor note-date)
     (author :initarg :author :initform nil :accessor note-author)
     (title :initarg :title :initform nil :accessor note-title)
     (lang :initarg :lang :initform nil :accessor note-lang)
     (code :initarg :code :initform nil :accessor note-code)))

Implementation of memory storage is trivial, so it's enough to site
just the class definition:

.. code-block:: common-lisp

  (defclass memory-storage ()
    ((notes :initform nil)
     (last-id :initform 0)))

Setting default value for :var:`*storage*` variable:

.. code-block:: common-lisp

  (setf *storage* (make-instance 'memory-storage))

routes.lisp
-----------

In this file, processed URL and opetation logic.
Because all logic of view is handled by :var:`*default-render-method*`
object, route handlers should just gather and preparare data for 
processing them with fucntion :fun:`restas:render-object`.
View logic, as I said before, is implimented on the basis of
`cl-closure-template`_ library which as input data format uses
*plist* (you can read about using *property list* in more details 
`here <http://lisper.ru/pcl/practical-a-simple-database>`_), so route handlers
generate data in this format.

A couple of helper functions translating record information to *plist* format:

.. code-block:: common-lisp

  (defun note-plist/short (note)
    (list :href (restas:genurl 'view-note :id (note-id note))
          :date (local-time:format-timestring nil (note-date note))
          :title (note-title note)
          :author (note-author note)))

  (defun note-plist (note)
    (list* :title (note-title note)
           :code (note-code note)
           :lang (note-lang note)
           (note-plist/short note)))

In this code, the following call is of the most interest:

.. code-block:: common-lisp

  (restas:genurl 'view-note :id (note-id note))

It generates URL for viewing record basing on route name ('view-node) and :id
parameter.

.. note:: None

  In route-based systems "manual" creation of URL is not a common practise,
  because automatic generation considerably increases flexebility of an 
  application and releaves you from many potential problems. Among other issues,
  in this cases the base URL will be taken in account which is address a module
  is plugged into and which is unknown at the module development stage.

Application entry point:

.. code-block:: common-lisp

  (restas:define-route main ("")
    (restas:redirect 'list-notes))

This route sends request to base URL where the module is activated,
adn simply redirects to the page with record list. For redirection 
:fun:`restas:redirect` function is used which, like :fun:`restas:genurl`,
processes the name of route (and a set of parameters, but 'list-notes route
doesn't have them) so there is no need in actual specifying the URL.

For displaying record list a page-by-page representation is used with limiting
of number of records on a single page which mustn't be more than :var:`*max-on-page*`
(this variable was introduced in **defmodule.lisp**). So, apart from the record list
itself you need to gather information about overal number of records,
and also provide links to previous and next pages:

.. code-block:: common-lisp

  (restas:define-route list-notes ("all")
    (let* ((total-count (storage-count-notes *storage*))
           (start (min (max (or (ignore-errors (parse-integer (hunchentoot:get-parameter "start")))
                                1)
                            1)
                       total-count)))
      (list :title "All notes"
            :notes (iter (for note in (storage-list-notes *storage*
                                                          (1- start)
                                                          *max-on-page*))
                         (collect (note-plist/short note)))
            :first start
            :total-count total-count
            :href-before (if (< (+ (1- start) *max-on-page*)
                                total-count)
                             (format nil
                                     "~A?start=~A"
                                     (restas:genurl 'list-notes)
                                     (+ start *max-on-page*)))
            :href-after (if (> start 1)
                            (format nil
                                    "~A?start=~A"
                                    (restas:genurl 'list-notes)
                                    (max (- start *max-on-page*) 1))))))

The given code is kind of more entangled than it should be, by the reason that
the really processed URL looks like this
::

  all?start=n

(where n is sequential number of the first record on the page) and `RESTAS`_ 
route system yet doesn't know hot to take into account GET parameters of
request.

For viewing a particular record responds the following route:

.. code-block:: common-lisp

  (restas:define-route view-note (":id"
                                  :parse-vars (list :id #'parse-integer))
    (note-plist (storage-get-note *storage* id)))

This handler is very simple, but it contains one interesting moment, the 
:parse-vars parameter. The identifier of record is ID, which should be
an integer number. This code lets you ensure that specified URL contains 
namely integer number and converts it from the string representation, os
handler code already works with the integer value.

Route for displaying form of creation of an record is yet more trivial:

.. code-block:: common-lisp

  (restas:define-route create-note ("create")
    (list :title "Создать"))

This form will support each of saving record and previewing it, therefore
for processing a POST request I used here two routes processing the same
URL:

.. code-block:: common-lisp

  (restas:define-route preview-note ("create"
                                     :method :post
                                     :requirement #'(lambda () (hunchentoot:post-parameter "preview")))
    (list :title (hunchentoot:post-parameter "title")
          :author (colorize-user)
          :code (hunchentoot:post-parameter "code")
          :lang (hunchentoot:post-parameter "lang")))


  (restas:define-route save-note ("create"
                                  :method :post
                                  :requirement #'(lambda () (hunchentoot:post-parameter "save")))
    (let ((author (colorize-user)))
      (if author
          (restas:redirect 'view-note
                           :id (note-id (storage-add-note
                                          *storage*
                                          (make-instance 'note
                                                         :code (hunchentoot:post-parameter "code")
                                                         :author author
                                                         :lang (hunchentoot:post-parameter "lang")
                                                         :title (hunchentoot:post-parameter "title")))))
          hunchentoot:+http-forbidden+)))

Selecting a route is done by :requirement property checking which command
(Save or Preview) was selected by a user. For checking whether a user has
the right to save the record :fun:`colorize-user` function is used (it was
defined in **defmodule.lisp**) and if the user doesn't authorised himself
then after a try to save a record he will get :const:`hunchentoot:+http-forbidden+`
status.

drawer.lisp
-----------

All routes defined above return data in the *plist* format, therefore
for selecting a template for processing passed data, in addition it is necessary
to use the name of the current route, which can be evaluated by

.. code-block:: common-lisp

  (restas:route-symbol restas:*route*)

and for this a generic method is defined:

.. code-block:: common-lisp

  (defgeneric render-route-data (drawer data route )
    (:documentation "Отображение страницы для указанного маршрута"))

It can be specialized with *eql* qualifier for each particular route.

In order to outside application could redefine the general theme of site
there is generic function:

.. code-block:: common-lisp

  (defgeneric finalize-page (drawer data)
    (:documentation "Формирование итоговой страницы"))

For syntax highliting CL has `colorize`_ library, which highlights Common
Lisp code very good, but, frankly speaking, is far away from been ideal.
So, for leaving possibility to use other instrument, which will probably
arise in the future, the following interfaces are defined with default 
implementation on the basis of `colorize`_:

.. code-block:: common-lisp

  (defgeneric colorize (drawer code lang)
    (:documentation "Генерация html с подсветкой кода")
    (:method (drawer code lang)
      (colorize::html-colorization lang code)))

  (defgeneric colorize-langs (drawer)
    (:documentation "Список поддерживаемых языков")
    (:method (drawer)
      (iter (for (id . title) in (colorize:coloring-types))
            (collect (list :id (symbol-name id)
                           :title title)))))

For specializing the call to :fun:`restas:render-object` and also for 
implementation of defined interfaces we need class:

.. code-block:: common-lisp

  (defclass drawer () ())

Implementation of :fun:`finalize-page` by default just calls a template
with the same name:

.. code-block:: common-lisp

  (defmethod finalize-page ((drawer drawer) data)
    (restas.colorize.view:finalize-page data))

Now :fun:`restas:render-object` can be written in the following form:

.. code-block:: common-lisp

  (defmethod restas:render-object ((drawer drawer) (data list))
    (let ((content (render-route-data drawer
                                      data
                                      (restas:route-symbol restas:*route*)))
          (menu (restas.colorize.view:main-menu
                 (list :href-all  (restas:genurl 'list-notes)
                       :href-create (restas:genurl 'create-note)))))
      (finalize-page drawer
                     (list :content content
                           :menu menu
                           :title (getf data :title)))))

Here takes place a call to :fun:`finalize-page`, where the following data
is passed in *plist* format:

* **content** - the basical content of page as generated by call to
  :fun:`render-route-data`

* **menu** - links for viewing records and creating a new record, used for
  displaying the common for all pages menu .

* **title** - the heading of page extracted from passed data

Implementation of :fun:`render-route-data` processes passed data with aid
of template, whose name matches the name of the passed route (here you can
find the using of well known "Prevailing of agreement over configuration"):

.. code-block:: common-lisp

  (defmethod render-route-data ((drawer drawer) list route)
    (funcall (find-symbol (symbol-name route)
                          '#:restas.colorize.view)
             data))

Several routes need additional processing of passed data which can't be done
at the template side, this is done with *eql*-based specializing:

.. code-block:: common-lisp

  (defmethod render-route-data ((drawer drawer) (data list) (route (eql 'view-note)))
    (call-next-method drawer
                      (list* :code (colorize drawer
                                             (getf data :code)
                                             (getf data :lang))
                             data)
                      route))

  (defmethod render-route-data ((drawer drawer) (data list) (route (eql 'create-note)))
    (call-next-method drawer
                      (list* :langs (colorize-langs drawer)
                             data)
                      route))

  (defmethod render-route-data ((drawer drawer) (data list) (route (eql 'preview-note)))
    (call-next-method drawer
                      (list* :langs (colorize-langs drawer)
                             :preview (colorize drawer
                                                (getf data :code)
                                                (getf data :lang))
                             data)
                      route))

Finally :var:`*default-render-method*` is assigned the default value:

.. code-block:: common-lisp

  (setf *default-render-method* (make-instance 'drawer))

Thereby for generation of a real content a complex system is used,
which, on the one hand is fully based on templates and on the other hand
each its aspect is defined as a generic function, so changing a way of representation
is is enough to define a drawer-inherited class and specialize required functions.

drawer.tmpl
-----------

Compilation of the templates file is done by code:

.. code-block:: common-lisp

  (defparameter *colorize-template-path*
    (merge-pathnames "src/drawer.tmpl"
                     (asdf:component-pathname (asdf:find-system '#:restas-colorize))))

  (closure-template:compile-template :common-lisp-backend
                                     *colorize-template-path*)

And the file itself has the following content:

А сам он имеет следующее содержание:
::

  {namespace restas.colorize.view}

  {template finalizePage}
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
      {\n}
      <html>
          <head>
      	      <meta http-equiv="Content-Type" content="text/html; charset='utf-8'" />

              {if $title}
                  <title>{$title}</title>
              {/if}
          </head>

          <body>
            {$menu |noAutoescape}
            
            {$content |noAutoescape}
          </body>
      </html>
  {/template}

  {template main-menu}
      <ul class="colorize-top-menu">
          <li>
              <a href="{$hrefAll}">Все записи</a>
          </li>

          <li>
              <a href="{$hrefCreate}">Создать</a>
          </li>
     </ul>
  {/template}

  {template show-note-info}
      <div class="info">
          Автор: <strong>{$author}</strong> - {$date}
      </div>
  {/template}
    
  {template list-notes}
      <div class="colorize-list-nav" >
          {if $hrefAfter}<a href="{$hrefAfter}">« Позже</a>{/if}
          {$first} - {min($first + length($notes) - 1, $totalCount)} 
          из {$totalCount}  
          {if $hrefBefore}<a href="{$hrefBefore}">Раньше »</a>{/if}
      </div>

      {foreach $note in $notes}
          <div class="note">
              <a href="{$note.href}">{$note.title != '' ? $note.title : '*notitle*'}</a>
              {call show-note-info data="$note" /}
          </div>
      {/foreach}
  {/template}

  {template view-note}
      <div class="note-detail">
          <strong>{$title}</strong>
          {call show-note-info data="all" /}
          <div class="code">
              {$code |noAutoescape}
          </div>
      </div>
  {/template}    
    
  {template create-note}
      <form method="post">
          <textarea rows="30" name="code" cols="80" style="width: 100%">{$code}</textarea>
          <table style="text-align: left">
              <tbody>
                  {if $preview and $author}
                      <tr>
                          <th>Описание:</th>
                          <td>
                              <input size="60" name="title" type="text" {if $title}value="{$title}"{/if}/>
                          </td>
                      </tr>
                  {/if}
                    
                  <tr>
                      <th>Форматировать как:</th>
                      <td>
                          <select name="lang" >
                              {foreach $l in $langs}
                                  <option {if $l.id == $lang}selected{/if} value="{$l.id}">{$l.title}</option>
                              {/foreach}
                          </select>
                      </td>
                  </tr>
              </tbody>
          </table>
        
          <input type="submit" value="Форматировать" name="preview" />
          {if $preview and $author}
              <input type="submit" value="Сохранить" name="save" />
          {/if}

          {if $preview}
              <h3>Предварительный просмотр</h3>
              <div class="code">
                  {$preview |noAutoescape}
              </div>
          {/if}
     </form>    
  {/template}

  {template preview-note}
      {call create-note data="all" /}
  {/template}

Usage
=====

For using the component described ealrier on the `lisper.ru`_ site I use
the following code:

.. code-block:: common-lisp

  (defclass pastebin-drawer (restas.colorize::drawer) ())

  (defmethod restas.colorize::finalize-page ((drawer pastebin-drawer) data)
    (rulisp-finalize-page  :title (getf data :title)
                           :css '("style.css" "colorize.css")
                           :content (concatenate 'string
                                                 (getf data :menu)
                                                 (getf data :content))))

  (restas:define-submodule rulisp-format (#:restas.colorize)
    (restas.colorize:*baseurl* '("apps" "format"))
    (restas.colorize:*max-on-page* 15)
    (restas.colorize:*storage* *rulisp-db-storage*)
    (restas.colorize:*colorize-user-function* #'compute-user-login-name)
    (restas.colorize:*default-render-method* (make-instance 'pastebin-drawer)))

Here are variables specified with dynamic variable binding:
the baseURL for activating the module, maximal number of records per page,
the way of storing the data, authentification mechanism, and also a correct
way of displaying for the commponent not to stay out of general design style.

Source code
===========

The source code of described application is almost completely sited above and is
available at the address http://github.com/archimag/restas-colorize. Not taking in
account the temlate file, the size of the source code is about 200 lines.

.. _RESTAS: http://restas.lisper.ru/
.. _lisper.ru: http://lisper.ru/
.. _cl-closure-template: http://code.google.com/p/cl-closure-template/
.. _colorize: http://www.cliki.net/colorize
